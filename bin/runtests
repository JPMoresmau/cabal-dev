#!/usr/bin/env bash
set -e

SANDBOX=cabal-dev

# We can't use the cabal-dev code until we know that we have the
# dependencies installed, and we need this bootstrapping done to
# install those dependencies into a sandbox.

# Bootstrap package db. cabal-dev can do this, but we want to build
# cabal-dev itself in a sandbox
function init-pkg-db {
    VER_STR="$(ghc-pkg --version)"
    case "$VER_STR" in
        "GHC package manager version 6.8."*)
            GHCVER=6.8
            PKGDB=${SANDBOX}/packages-6.8.conf
            [ -f "${PKGDB}" ] || echo -n "[]" > "${PKGDB}"
            ;;
        "GHC package manager version 6.10."*)
            GHCVER=6.10
            PKGDB=${SANDBOX}/packages-6.10.conf
            [ -f "${PKGDB}" ] || echo -n "[]" > "${PKGDB}"
            ;;
        "GHC package manager version 6.12."*)
            GHCVER=6.12
            PKGDB=${SANDBOX}/packages.conf.d
            [ -d "${PKGDB}" ] || ghc-pkg init "${PKGDB}"
            ;;
        *)
            echo "This script can handle ghc-pkg 6.10 and " \
                "6.12, but cannot handle other versions" 1>&2
            exit 1
            ;;
    esac
}

# re-write the cabal-install config file to have absolute paths and
# reference the correct package database. This is a hacky
# implementation of the same thing that
# Distribution.Dev.RewriteCabalConfig does.
rewriteCabalConfig () {
    CFGIN="$1"
    CFGOUT="$2"
    HERE=$(pwd)
    OUT="${CFGOUT}.tmp"
    TILDE=$(echo "$HOME" | sed 's/\//\\\//g')
    DOT=$(pwd | sed 's/\//\\\//g')
    PKG=$(basename "${PKGDB}" | sed 's/\//\\\//g')
    sed -e 's/ ~\//'"$TILDE"'\//g' \
        -e 's/ \.\// '"$DOT"'\//g' "$CFGIN" \
        -e 's/\/packages.conf$/\/'"${PKG}"'/g' > "${OUT}"
    mv "${OUT}" "${CFGOUT}"
}

mkdir -p $SANDBOX
init-pkg-db
rewriteCabalConfig admin/cabal-config.in "${SANDBOX}/cabal.config"
case ${GHCVER} in
    6.8)
        CABALARGS="--with-ghc-pkg=$(which ghc-pkg-6.8-compat) \
            --ghc-pkg-options=--with-ghc-pkg=$(which ghc-pkg)"
        ;;
    *)
        CABALARGS=
        ;;
esac
cabal ${CABALARGS} --config-file="${SANDBOX}/cabal.config" install
cat <<EOF
==================================================
Now using the compiled binary:

EOF

checkExitSuccess () {
    echo -n "Checking exit status for args: $@ ... "
    "${SANDBOX}/bin/cabal-dev" "$@" > /dev/null
    if [ "$?" -ne "0" ]
    then
        echo FAILED
        exit 1
    else
        echo ok.
    fi
}

# Since set -e is on, these commands just check to make sure that
# these flags exit with success:
checkExitSuccess --version
checkExitSuccess --numeric-version
checkExitSuccess --help

# Add the new binaries to the path
PATH="${SANDBOX}/bin:$PATH"

# Make an sdist for the current source tree and put it in the index
# for the sandbox repo
"${SANDBOX}/bin/cabal-dev" add-source .

# re-install from the sdist version, to make sure the packaging is sane
"${SANDBOX}/bin/cabal-dev" install cabal-dev
